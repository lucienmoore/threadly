import {
  BasePlugin
} from "./chunk-OMR6GRNR.js";
import "./chunk-WXXH56N5.js";

// node_modules/@uppy/xhr-upload/node_modules/nanoid/non-secure/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (size = 21) => {
  let id5 = "";
  let i = size;
  while (i--) {
    id5 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id5;
};

// node_modules/@uppy/utils/lib/EventManager.js
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
var _uppy = _classPrivateFieldLooseKey("uppy");
var _events = _classPrivateFieldLooseKey("events");
var EventManager = class {
  constructor(uppy) {
    Object.defineProperty(this, _uppy, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _events, {
      writable: true,
      value: []
    });
    _classPrivateFieldLooseBase(this, _uppy)[_uppy] = uppy;
  }
  on(event, fn) {
    _classPrivateFieldLooseBase(this, _events)[_events].push([event, fn]);
    return _classPrivateFieldLooseBase(this, _uppy)[_uppy].on(event, fn);
  }
  remove() {
    for (const [event, fn] of _classPrivateFieldLooseBase(this, _events)[_events].splice(0)) {
      _classPrivateFieldLooseBase(this, _uppy)[_uppy].off(event, fn);
    }
  }
  onFilePause(fileID, cb) {
    this.on("upload-pause", (targetFileID, isPaused) => {
      if (fileID === targetFileID) {
        cb(isPaused);
      }
    });
  }
  onFileRemove(fileID, cb) {
    this.on("file-removed", (file) => {
      if (fileID === file.id)
        cb(file.id);
    });
  }
  onPause(fileID, cb) {
    this.on("upload-pause", (targetFileID, isPaused) => {
      if (fileID === targetFileID) {
        cb(isPaused);
      }
    });
  }
  onRetry(fileID, cb) {
    this.on("upload-retry", (targetFileID) => {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  onRetryAll(fileID, cb) {
    this.on("retry-all", () => {
      if (!_classPrivateFieldLooseBase(this, _uppy)[_uppy].getFile(fileID))
        return;
      cb();
    });
  }
  onPauseAll(fileID, cb) {
    this.on("pause-all", () => {
      if (!_classPrivateFieldLooseBase(this, _uppy)[_uppy].getFile(fileID))
        return;
      cb();
    });
  }
  onCancelAll(fileID, eventHandler) {
    var _this = this;
    this.on("cancel-all", function() {
      if (!_classPrivateFieldLooseBase(_this, _uppy)[_uppy].getFile(fileID))
        return;
      eventHandler(...arguments);
    });
  }
  onResumeAll(fileID, cb) {
    this.on("resume-all", () => {
      if (!_classPrivateFieldLooseBase(this, _uppy)[_uppy].getFile(fileID))
        return;
      cb();
    });
  }
};

// node_modules/@uppy/utils/lib/ProgressTimeout.js
function _classPrivateFieldLooseBase2(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id2 = 0;
function _classPrivateFieldLooseKey2(name) {
  return "__private_" + id2++ + "_" + name;
}
var _aliveTimer = _classPrivateFieldLooseKey2("aliveTimer");
var _isDone = _classPrivateFieldLooseKey2("isDone");
var _onTimedOut = _classPrivateFieldLooseKey2("onTimedOut");
var _timeout = _classPrivateFieldLooseKey2("timeout");
var ProgressTimeout = class {
  constructor(timeout, timeoutHandler) {
    Object.defineProperty(this, _aliveTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isDone, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _onTimedOut, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _timeout, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase2(this, _timeout)[_timeout] = timeout;
    _classPrivateFieldLooseBase2(this, _onTimedOut)[_onTimedOut] = timeoutHandler;
  }
  progress() {
    if (_classPrivateFieldLooseBase2(this, _isDone)[_isDone])
      return;
    if (_classPrivateFieldLooseBase2(this, _timeout)[_timeout] > 0) {
      clearTimeout(_classPrivateFieldLooseBase2(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase2(this, _aliveTimer)[_aliveTimer] = setTimeout(_classPrivateFieldLooseBase2(this, _onTimedOut)[_onTimedOut], _classPrivateFieldLooseBase2(this, _timeout)[_timeout]);
    }
  }
  done() {
    if (!_classPrivateFieldLooseBase2(this, _isDone)[_isDone]) {
      clearTimeout(_classPrivateFieldLooseBase2(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase2(this, _aliveTimer)[_aliveTimer] = void 0;
      _classPrivateFieldLooseBase2(this, _isDone)[_isDone] = true;
    }
  }
};
var ProgressTimeout_default = ProgressTimeout;

// node_modules/@uppy/utils/lib/RateLimitedQueue.js
function _classPrivateFieldLooseBase3(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id3 = 0;
function _classPrivateFieldLooseKey3(name) {
  return "__private_" + id3++ + "_" + name;
}
function createCancelError(cause) {
  return new Error("Cancelled", {
    cause
  });
}
function abortOn(signal) {
  if (signal != null) {
    var _this$then;
    const abortPromise = () => this.abort(signal.reason);
    signal.addEventListener("abort", abortPromise, {
      once: true
    });
    const removeAbortListener = () => {
      signal.removeEventListener("abort", abortPromise);
    };
    (_this$then = this.then) == null ? void 0 : _this$then.call(this, removeAbortListener, removeAbortListener);
  }
  return this;
}
var _activeRequests = _classPrivateFieldLooseKey3("activeRequests");
var _queuedHandlers = _classPrivateFieldLooseKey3("queuedHandlers");
var _paused = _classPrivateFieldLooseKey3("paused");
var _pauseTimer = _classPrivateFieldLooseKey3("pauseTimer");
var _downLimit = _classPrivateFieldLooseKey3("downLimit");
var _upperLimit = _classPrivateFieldLooseKey3("upperLimit");
var _rateLimitingTimer = _classPrivateFieldLooseKey3("rateLimitingTimer");
var _call = _classPrivateFieldLooseKey3("call");
var _queueNext = _classPrivateFieldLooseKey3("queueNext");
var _next = _classPrivateFieldLooseKey3("next");
var _queue = _classPrivateFieldLooseKey3("queue");
var _dequeue = _classPrivateFieldLooseKey3("dequeue");
var _resume = _classPrivateFieldLooseKey3("resume");
var _increaseLimit = _classPrivateFieldLooseKey3("increaseLimit");
var RateLimitedQueue = class {
  constructor(limit) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    });
    Object.defineProperty(this, _queue, {
      value: _queue2
    });
    Object.defineProperty(this, _next, {
      value: _next2
    });
    Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    });
    Object.defineProperty(this, _call, {
      value: _call2
    });
    Object.defineProperty(this, _activeRequests, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _queuedHandlers, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _paused, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _pauseTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _downLimit, {
      writable: true,
      value: 1
    });
    Object.defineProperty(this, _upperLimit, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rateLimitingTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _resume, {
      writable: true,
      value: () => this.resume()
    });
    Object.defineProperty(this, _increaseLimit, {
      writable: true,
      value: () => {
        if (_classPrivateFieldLooseBase3(this, _paused)[_paused]) {
          _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], 0);
          return;
        }
        _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] = this.limit;
        this.limit = Math.ceil((_classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit]) / 2);
        for (let i = _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit]; i <= this.limit; i++) {
          _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
        }
        if (_classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] > 3) {
          _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], 2e3);
        } else {
          _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase3(this, _downLimit)[_downLimit] / 2);
        }
      }
    });
    if (typeof limit !== "number" || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }
  }
  run(fn, queueOptions) {
    if (!_classPrivateFieldLooseBase3(this, _paused)[_paused] && _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] < this.limit) {
      return _classPrivateFieldLooseBase3(this, _call)[_call](fn);
    }
    return _classPrivateFieldLooseBase3(this, _queue)[_queue](fn, queueOptions);
  }
  wrapSyncFunction(fn, queueOptions) {
    var _this = this;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const queuedRequest = _this.run(() => {
        fn(...args);
        queueMicrotask(() => queuedRequest.done());
        return () => {
        };
      }, queueOptions);
      return {
        abortOn,
        abort() {
          queuedRequest.abort();
        }
      };
    };
  }
  wrapPromiseFunction(fn, queueOptions) {
    var _this2 = this;
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      let queuedRequest;
      const outerPromise = new Promise((resolve, reject) => {
        queuedRequest = _this2.run(() => {
          let cancelError;
          let innerPromise;
          try {
            innerPromise = Promise.resolve(fn(...args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }
          innerPromise.then((result) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, (err) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return (cause) => {
            cancelError = createCancelError(cause);
          };
        }, queueOptions);
      });
      outerPromise.abort = (cause) => {
        queuedRequest.abort(cause);
      };
      outerPromise.abortOn = abortOn;
      return outerPromise;
    };
  }
  resume() {
    _classPrivateFieldLooseBase3(this, _paused)[_paused] = false;
    clearTimeout(_classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer]);
    for (let i = 0; i < this.limit; i++) {
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    }
  }
  /**
   * Freezes the queue for a while or indefinitely.
   *
   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
   *                                    If omitted, the queue won't resume automatically.
   */
  pause(duration) {
    if (duration === void 0) {
      duration = null;
    }
    _classPrivateFieldLooseBase3(this, _paused)[_paused] = true;
    clearTimeout(_classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer]);
    if (duration != null) {
      _classPrivateFieldLooseBase3(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _resume)[_resume], duration);
    }
  }
  /**
   * Pauses the queue for a duration, and lower the limit of concurrent requests
   * when the queue resumes. When the queue resumes, it tries to progressively
   * increase the limit in `this.#increaseLimit` until another call is made to
   * `this.rateLimit`.
   * Call this function when using the RateLimitedQueue for network requests and
   * the remote server responds with 429 HTTP code.
   *
   * @param {number} duration in milliseconds.
   */
  rateLimit(duration) {
    clearTimeout(_classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer]);
    this.pause(duration);
    if (this.limit > 1 && Number.isFinite(this.limit)) {
      _classPrivateFieldLooseBase3(this, _upperLimit)[_upperLimit] = this.limit - 1;
      this.limit = _classPrivateFieldLooseBase3(this, _downLimit)[_downLimit];
      _classPrivateFieldLooseBase3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase3(this, _increaseLimit)[_increaseLimit], duration);
    }
  }
  get isPaused() {
    return _classPrivateFieldLooseBase3(this, _paused)[_paused];
  }
};
function _call2(fn) {
  _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] += 1;
  let done = false;
  let cancelActive;
  try {
    cancelActive = fn();
  } catch (err) {
    _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
    throw err;
  }
  return {
    abort: (cause) => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
      cancelActive == null ? void 0 : cancelActive(cause);
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    },
    done: () => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] -= 1;
      _classPrivateFieldLooseBase3(this, _queueNext)[_queueNext]();
    }
  };
}
function _queueNext2() {
  queueMicrotask(() => _classPrivateFieldLooseBase3(this, _next)[_next]());
}
function _next2() {
  if (_classPrivateFieldLooseBase3(this, _paused)[_paused] || _classPrivateFieldLooseBase3(this, _activeRequests)[_activeRequests] >= this.limit) {
    return;
  }
  if (_classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].length === 0) {
    return;
  }
  const next = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].shift();
  const handler = _classPrivateFieldLooseBase3(this, _call)[_call](next.fn);
  next.abort = handler.abort;
  next.done = handler.done;
}
function _queue2(fn, options) {
  if (options === void 0) {
    options = {};
  }
  const handler = {
    fn,
    priority: options.priority || 0,
    abort: () => {
      _classPrivateFieldLooseBase3(this, _dequeue)[_dequeue](handler);
    },
    done: () => {
      throw new Error("Cannot mark a queued request as done: this indicates a bug");
    }
  };
  const index = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
    return handler.priority > other.priority;
  });
  if (index === -1) {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].push(handler);
  } else {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
  }
  return handler;
}
function _dequeue2(handler) {
  const index = _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
  if (index !== -1) {
    _classPrivateFieldLooseBase3(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
  }
}
var internalRateLimitedQueue = Symbol("__queue");

// node_modules/@uppy/utils/lib/NetworkError.js
var NetworkError = class extends Error {
  constructor(error, xhr) {
    if (xhr === void 0) {
      xhr = null;
    }
    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
    this.cause = error;
    this.isNetworkError = true;
    this.request = xhr;
  }
};
var NetworkError_default = NetworkError;

// node_modules/@uppy/utils/lib/isNetworkError.js
function isNetworkError(xhr) {
  if (!xhr) {
    return false;
  }
  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}
var isNetworkError_default = isNetworkError;

// node_modules/@uppy/utils/lib/fileFilters.js
function filterNonFailedFiles(files) {
  const hasError = (file) => "error" in file && !!file.error;
  return files.filter((file) => !hasError(file));
}
function filterFilesToEmitUploadStarted(files) {
  return files.filter((file) => {
    var _file$progress;
    return !((_file$progress = file.progress) != null && _file$progress.uploadStarted) || !file.isRestored;
  });
}

// node_modules/@uppy/xhr-upload/lib/locale.js
var locale_default = {
  strings: {
    // Shown in the Informer if an upload is being canceled because it stalled for too long.
    uploadStalled: "Upload has not made any progress for %{seconds} seconds. You may want to retry it."
  }
};

// node_modules/@uppy/xhr-upload/lib/index.js
function _classPrivateFieldLooseBase4(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id4 = 0;
function _classPrivateFieldLooseKey4(name) {
  return "__private_" + id4++ + "_" + name;
}
var packageJson = {
  "version": "3.6.0"
};
function buildResponseError(xhr, err) {
  let error = err;
  if (!error)
    error = new Error("Upload error");
  if (typeof error === "string")
    error = new Error(error);
  if (!(error instanceof Error)) {
    error = Object.assign(new Error("Upload error"), {
      data: error
    });
  }
  if (isNetworkError_default(xhr)) {
    error = new NetworkError_default(error, xhr);
    return error;
  }
  error.request = xhr;
  return error;
}
function setTypeInBlob(file) {
  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);
  return dataWithUpdatedType;
}
var _uploadLocalFile = _classPrivateFieldLooseKey4("uploadLocalFile");
var _uploadBundle = _classPrivateFieldLooseKey4("uploadBundle");
var _getCompanionClientArgs = _classPrivateFieldLooseKey4("getCompanionClientArgs");
var _uploadFiles = _classPrivateFieldLooseKey4("uploadFiles");
var _handleUpload = _classPrivateFieldLooseKey4("handleUpload");
var XHRUpload = class extends BasePlugin {
  constructor(uppy, _opts) {
    super(uppy, _opts);
    Object.defineProperty(this, _uploadFiles, {
      value: _uploadFiles2
    });
    Object.defineProperty(this, _getCompanionClientArgs, {
      value: _getCompanionClientArgs2
    });
    Object.defineProperty(this, _uploadBundle, {
      value: _uploadBundle2
    });
    Object.defineProperty(this, _uploadLocalFile, {
      value: _uploadLocalFile2
    });
    Object.defineProperty(this, _handleUpload, {
      writable: true,
      value: async (fileIDs) => {
        if (fileIDs.length === 0) {
          this.uppy.log("[XHRUpload] No files to upload!");
          return;
        }
        if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {
          this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning");
        }
        this.uppy.log("[XHRUpload] Uploading...");
        const files = this.uppy.getFilesByIds(fileIDs);
        const filesFiltered = filterNonFailedFiles(files);
        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);
        this.uppy.emit("upload-start", filesToEmit);
        if (this.opts.bundle) {
          const isSomeFileRemote = filesFiltered.some((file) => file.isRemote);
          if (isSomeFileRemote) {
            throw new Error("Canâ€™t upload remote files when the `bundle: true` option is set");
          }
          if (typeof this.opts.headers === "function") {
            throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");
          }
          await _classPrivateFieldLooseBase4(this, _uploadBundle)[_uploadBundle](filesFiltered);
        } else {
          await _classPrivateFieldLooseBase4(this, _uploadFiles)[_uploadFiles](filesFiltered);
        }
      }
    });
    this.type = "uploader";
    this.id = this.opts.id || "XHRUpload";
    this.title = "XHRUpload";
    this.defaultLocale = locale_default;
    const defaultOptions = {
      formData: true,
      fieldName: _opts.bundle ? "files[]" : "file",
      method: "post",
      allowedMetaFields: null,
      responseUrlFieldName: "url",
      bundle: false,
      headers: {},
      timeout: 30 * 1e3,
      limit: 5,
      withCredentials: false,
      responseType: "",
      /**
       * @param {string} responseText the response body string
       */
      getResponseData(responseText) {
        let parsedResponse = {};
        try {
          parsedResponse = JSON.parse(responseText);
        } catch (err) {
          uppy.log(err);
        }
        return parsedResponse;
      },
      /**
       *
       * @param {string} _ the response body string
       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)
       */
      getResponseError(_, response) {
        let error = new Error("Upload error");
        if (isNetworkError_default(response)) {
          error = new NetworkError_default(error, response);
        }
        return error;
      },
      /**
       * Check if the response from the upload endpoint indicates that the upload was successful.
       *
       * @param {number} status the response status code
       */
      validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    this.opts = {
      ...defaultOptions,
      ..._opts
    };
    this.i18nInit();
    if (internalRateLimitedQueue in this.opts) {
      this.requests = this.opts[internalRateLimitedQueue];
    } else {
      this.requests = new RateLimitedQueue(this.opts.limit);
    }
    if (this.opts.bundle && !this.opts.formData) {
      throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");
    }
    if ((_opts == null ? void 0 : _opts.allowedMetaFields) === void 0 && "metaFields" in this.opts) {
      throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`.");
    }
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
  }
  getOptions(file) {
    const overrides = this.uppy.getState().xhrUpload;
    const {
      headers
    } = this.opts;
    const opts = {
      ...this.opts,
      ...overrides || {},
      ...file.xhrUpload || {},
      headers: {}
    };
    if (typeof headers === "function") {
      opts.headers = headers(file);
    } else {
      Object.assign(opts.headers, this.opts.headers);
    }
    if (overrides) {
      Object.assign(opts.headers, overrides.headers);
    }
    if (file.xhrUpload) {
      Object.assign(opts.headers, file.xhrUpload.headers);
    }
    return opts;
  }
  // eslint-disable-next-line class-methods-use-this
  addMetadata(formData, meta, opts) {
    const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(meta);
    allowedMetaFields.forEach((item) => {
      if (Array.isArray(meta[item])) {
        meta[item].forEach((subItem) => formData.append(item, subItem));
      } else {
        formData.append(item, meta[item]);
      }
    });
  }
  createFormDataUpload(file, opts) {
    const formPost = new FormData();
    this.addMetadata(formPost, file.meta, opts);
    const dataWithUpdatedType = setTypeInBlob(file);
    if (file.name) {
      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);
    } else {
      formPost.append(opts.fieldName, dataWithUpdatedType);
    }
    return formPost;
  }
  createBundledUpload(files, opts) {
    const formPost = new FormData();
    const {
      meta
    } = this.uppy.getState();
    this.addMetadata(formPost, meta, opts);
    files.forEach((file) => {
      const options = this.getOptions(file);
      const dataWithUpdatedType = setTypeInBlob(file);
      if (file.name) {
        formPost.append(options.fieldName, dataWithUpdatedType, file.name);
      } else {
        formPost.append(options.fieldName, dataWithUpdatedType);
      }
    });
    return formPost;
  }
  install() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: false
        }
      });
    }
    this.uppy.addUploader(_classPrivateFieldLooseBase4(this, _handleUpload)[_handleUpload]);
  }
  uninstall() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: true
        }
      });
    }
    this.uppy.removeUploader(_classPrivateFieldLooseBase4(this, _handleUpload)[_handleUpload]);
  }
};
async function _uploadLocalFile2(file, current, total) {
  const opts = this.getOptions(file);
  this.uppy.log(`uploading ${current} of ${total}`);
  return new Promise((resolve, reject) => {
    const data = opts.formData ? this.createFormDataUpload(file, opts) : file.data;
    const xhr = new XMLHttpRequest();
    const eventManager = new EventManager(this.uppy);
    this.uploaderEvents[file.id] = eventManager;
    let queuedRequest;
    const timer = new ProgressTimeout_default(opts.timeout, () => {
      const error = new Error(this.i18n("uploadStalled", {
        seconds: Math.ceil(opts.timeout / 1e3)
      }));
      this.uppy.emit("upload-stalled", error, [file]);
    });
    const id5 = nanoid();
    xhr.upload.addEventListener("loadstart", () => {
      this.uppy.log(`[XHRUpload] ${id5} started`);
    });
    xhr.upload.addEventListener("progress", (ev) => {
      this.uppy.log(`[XHRUpload] ${id5} progress: ${ev.loaded} / ${ev.total}`);
      timer.progress();
      if (ev.lengthComputable) {
        this.uppy.emit("upload-progress", file, {
          uploader: this,
          bytesUploaded: ev.loaded,
          bytesTotal: ev.total
        });
      }
    });
    xhr.addEventListener("load", () => {
      this.uppy.log(`[XHRUpload] ${id5} finished`);
      timer.done();
      queuedRequest.done();
      if (this.uploaderEvents[file.id]) {
        this.uploaderEvents[file.id].remove();
        this.uploaderEvents[file.id] = null;
      }
      if (opts.validateStatus(xhr.status, xhr.responseText, xhr)) {
        const body2 = opts.getResponseData(xhr.responseText, xhr);
        const uploadURL = body2[opts.responseUrlFieldName];
        const uploadResp = {
          status: xhr.status,
          body: body2,
          uploadURL
        };
        this.uppy.emit("upload-success", file, uploadResp);
        if (uploadURL) {
          this.uppy.log(`Download ${file.name} from ${uploadURL}`);
        }
        return resolve(file);
      }
      const body = opts.getResponseData(xhr.responseText, xhr);
      const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
      const response = {
        status: xhr.status,
        body
      };
      this.uppy.emit("upload-error", file, error, response);
      return reject(error);
    });
    xhr.addEventListener("error", () => {
      this.uppy.log(`[XHRUpload] ${id5} errored`);
      timer.done();
      queuedRequest.done();
      if (this.uploaderEvents[file.id]) {
        this.uploaderEvents[file.id].remove();
        this.uploaderEvents[file.id] = null;
      }
      const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
      this.uppy.emit("upload-error", file, error);
      return reject(error);
    });
    xhr.open(opts.method.toUpperCase(), opts.endpoint, true);
    xhr.withCredentials = opts.withCredentials;
    if (opts.responseType !== "") {
      xhr.responseType = opts.responseType;
    }
    queuedRequest = this.requests.run(() => {
      const currentOpts = this.getOptions(file);
      Object.keys(currentOpts.headers).forEach((header) => {
        xhr.setRequestHeader(header, currentOpts.headers[header]);
      });
      xhr.send(data);
      return () => {
        timer.done();
        xhr.abort();
      };
    });
    eventManager.onFileRemove(file.id, () => {
      queuedRequest.abort();
      reject(new Error("File removed"));
    });
    eventManager.onCancelAll(file.id, (_ref) => {
      let {
        reason
      } = _ref;
      if (reason === "user") {
        queuedRequest.abort();
      }
      reject(new Error("Upload cancelled"));
    });
  });
}
function _uploadBundle2(files) {
  return new Promise((resolve, reject) => {
    const {
      endpoint
    } = this.opts;
    const {
      method
    } = this.opts;
    const optsFromState = this.uppy.getState().xhrUpload;
    const formData = this.createBundledUpload(files, {
      ...this.opts,
      ...optsFromState || {}
    });
    const xhr = new XMLHttpRequest();
    const emitError = (error) => {
      files.forEach((file) => {
        this.uppy.emit("upload-error", file, error);
      });
    };
    const timer = new ProgressTimeout_default(this.opts.timeout, () => {
      const error = new Error(this.i18n("uploadStalled", {
        seconds: Math.ceil(this.opts.timeout / 1e3)
      }));
      this.uppy.emit("upload-stalled", error, files);
    });
    xhr.upload.addEventListener("loadstart", () => {
      this.uppy.log("[XHRUpload] started uploading bundle");
      timer.progress();
    });
    xhr.upload.addEventListener("progress", (ev) => {
      timer.progress();
      if (!ev.lengthComputable)
        return;
      files.forEach((file) => {
        this.uppy.emit("upload-progress", file, {
          uploader: this,
          bytesUploaded: ev.loaded / ev.total * file.size,
          bytesTotal: file.size
        });
      });
    });
    xhr.addEventListener("load", (ev) => {
      timer.done();
      if (this.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {
        const body = this.opts.getResponseData(xhr.responseText, xhr);
        const uploadResp = {
          status: ev.target.status,
          body
        };
        files.forEach((file) => {
          this.uppy.emit("upload-success", file, uploadResp);
        });
        return resolve();
      }
      const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
      error.request = xhr;
      emitError(error);
      return reject(error);
    });
    xhr.addEventListener("error", () => {
      timer.done();
      const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
      emitError(error);
      return reject(error);
    });
    this.uppy.on("cancel-all", function(_temp) {
      let {
        reason
      } = _temp === void 0 ? {} : _temp;
      if (reason !== "user")
        return;
      timer.done();
      xhr.abort();
    });
    xhr.open(method.toUpperCase(), endpoint, true);
    xhr.withCredentials = this.opts.withCredentials;
    if (this.opts.responseType !== "") {
      xhr.responseType = this.opts.responseType;
    }
    Object.keys(this.opts.headers).forEach((header) => {
      xhr.setRequestHeader(header, this.opts.headers[header]);
    });
    xhr.send(formData);
  });
}
function _getCompanionClientArgs2(file) {
  const opts = this.getOptions(file);
  const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(file.meta);
  return {
    ...file.remote.body,
    protocol: "multipart",
    endpoint: opts.endpoint,
    size: file.data.size,
    fieldname: opts.fieldName,
    metadata: Object.fromEntries(allowedMetaFields.map((name) => [name, file.meta[name]])),
    httpMethod: opts.method,
    useFormData: opts.formData,
    headers: opts.headers
  };
}
async function _uploadFiles2(files) {
  await Promise.allSettled(files.map((file, i) => {
    const current = parseInt(i, 10) + 1;
    const total = files.length;
    if (file.isRemote) {
      const getQueue = () => this.requests;
      const controller = new AbortController();
      const removedHandler = (removedFile) => {
        if (removedFile.id === file.id)
          controller.abort();
      };
      this.uppy.on("file-removed", removedHandler);
      const uploadPromise = this.uppy.getRequestClientForFile(file).uploadRemoteFile(file, _classPrivateFieldLooseBase4(this, _getCompanionClientArgs)[_getCompanionClientArgs](file), {
        signal: controller.signal,
        getQueue
      });
      this.requests.wrapSyncFunction(() => {
        this.uppy.off("file-removed", removedHandler);
      }, {
        priority: -1
      })();
      return uploadPromise;
    }
    return _classPrivateFieldLooseBase4(this, _uploadLocalFile)[_uploadLocalFile](file, current, total);
  }));
}
XHRUpload.VERSION = packageJson.version;
export {
  XHRUpload as default
};
//# sourceMappingURL=@uppy_xhr-upload.js.map
